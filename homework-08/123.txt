GP018302,
1.为什么要使用线程池？
防止用户无节制创建线程，通过线程重用节省频繁创建、回收线程的开销。
2.Executors提供的四种线程池:newSingleThreadExecutor,newFixedThreadPool,newCachedThreadPool,newScheduledThreadPool ，请说出他们的区别以及应用场景
newSingleThreadExecutor：只有一个线程的线程池，可以按照FIFO规则执行。
newFixedThreadPool：固定数量线程池，有用户请求是会将任务挂起在任务队列，有空闲线程就会去执行任务，没有空闲线程则暂时挂起。
newCachedThreadPool：缓存线程池，最大线程数量接近无限，但是空闲线程的存活时间只有60s。
newScheduledThreadPool ：固定数量线程池，有延迟性和周期性，可做定时任务。

3.线程池有哪几种工作队列？
BlockingQueue是双缓冲队列。BlockingQueue内部使用两条队列，允许两个线程同时向队列一个存储，一个取出操作。在保证并发安全的同时，提高了队列的存取效率。
ArrayBlockingQueue规定大小的BlockingQueue队列，必须指定大小，它包含的对象都是FIFO顺序排序的
LinkeBlockingQueue 底层实现为单向链表，阻塞队列，实现并发读写。线程池中使用无界的
DelayedWorkQueue 内部数据结构为小根堆，按照到期时间排序。每次take时，如果没有到期的任务，会阻塞。如果有，取出到期时间最近的任务。
PriorityBlockingQueue类似于LinkedBlockingQueue，但是其所含对象的排序不是FIFO，而是依据对象的自然顺序或者构造函数的Comparator决定。
SynchronousQueue特殊的BlockingQueue队列，对其的操作必须是放和取交替完成。

4.线程池默认的拒绝策略有哪些
AbortPolicy：直接抛出异常
CallerRunsPolicy：用调用者所在的线程执行任务
DiscardOldestPolicy：丢弃你阻塞队列中最靠前的任务，并执行当前任务
DiscardPolicy：丢弃任务

5.如何理解有界队列和无解队列
有界队列：队列长度有限，如带capacity参数的LinkedBlockingQueue, ArrayBlockingQueue。使用有界队列，当队列满了且maximumPoolSize>corePoolSize，会创建新的worker处理任务。有界队列需要同时调整核心线程数、最大线程数、队列长度三个参数。当场景发生变化时，很难适应，比如任务数量剧增。有界队列适合任务生产与消费速度比较稳定的场景。
无界队列：队列长度不受限，如没有capacity参数的LinkedBlockingQueue。此时，maximumPoolSize参数及拒绝策略没有意义，新任务会被加到阻塞队列中。当任务生产速度远大于消费速度时，无界队列可能导致内存溢出。无界队列适合任务为CPU密集型，且任务生产速度与消费速度相当的场景。
6.线程池是如何实现线程回收的？ 以及核心线程能不能被回收？
当参数allowCoreThreadTimeOut为true，当前线程池的大小大于核心线程池大小（corePoolSize）,满足这两个条件后，一个线程在keepAliveTime时间内未获取的到任务时即空闲了这么久，该线程就会被回收。回收方法shutdown()和shutdownnow()

核心线程可以被回收。

7.FutureTask是什么
FutureTask继承了RunnableFuture接口，用于异步获取执行结果或取消任务，在高并发场景下保证任务只执行一次。

8.Thread.sleep(0)的作用是什么
在抢占式CPU调度中，通知CPU释放本线程的执行权，触发操作系统立刻重新进行一次CPU竞争

9.如果提交任务时，线程池队列已满，这时会发生什么
最大线程数>核心线程数，增加worker, 最大线程数等于核心线程数或worker数量大于最大线程数，执行抛弃策略

10.如果一个线程池中还有任务没有执行完成，这个时候是否允许被外部中断？
允许，线程池的关闭方式包括java.util.concurrent.ThreadPoolExecutor#shutdown, java.util.concurrent.ThreadPoolExecutor#shutdownNow。
其中shutdown允许线程池执行完队列中的任务，不再接受新任务。
shutdownNow会终止所有任务。
shutdown会interrupt空闲worker
shutdownNow会interrupt所有worker
所以用户线程必须可以通过interrupt方式被终止，线程池shutdown, shutdownNow才会起作用。